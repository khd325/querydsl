# 기본 문법

---

## JPQL Vs Querydsl

---


```java
@SpringBootTest
@Transactional
public class QuerydslBasicTest {

    @Autowired
    EntityManager em;

    JPAQueryFactory queryFactory;

    @BeforeEach
    public void before() {

        queryFactory = new JPAQueryFactory(em);

        Team teamA = new Team("teamA");
        Team teamB = new Team("teamB");

        em.persist(teamA);
        em.persist(teamB);

        Member member1 = new Member("member1", 10, teamA);
        Member member2 = new Member("member2", 20, teamA);

        Member member3 = new Member("member3", 30, teamB);
        Member member4 = new Member("member4", 40, teamB);

        em.persist(member1);
        em.persist(member2);
        em.persist(member3);
        em.persist(member4);
    }

    @Test
    public void startJPQL() {
        //find member1
        String qlString = "select m from Member m where m.username = :username";
        Member findMember = em.createQuery(qlString, Member.class)
                .setParameter("username", "member1")
                .getSingleResult();

        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
}
```

```java
    @Test
    public void startQuerydsl(){


        QMember m = new QMember("m");

        Member findMember = queryFactory
                .select(m)
                .from(m)
                .where(m.username.eq("member1"))
                .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
```

queryFactor를 생성하고(`before()`) sql처럼 사용한다.

JPQL은 실행 시점에 오류를 알지만 Querydsl은 컴파일 시점에 오류를 발견할 수 있다.

파라미터 바인딩 또한 JPQL은 직접 바인딩 하지만, Querydsl은 자동으로 처리


---

## 기본 Q-Type 활용

```java
QMember qMember = new QMember("m") //별칭 직접 지정
QMember qMember = QMember.member; //기본 인스턴스 사용
```

static import 사용

```java
@SpringBootTest
@Transactional
public class QuerydslBasicTest {

    @Autowired
    EntityManager em;

    JPAQueryFactory queryFactory;
    
    @Test
    public void startQuerydsl(){
        Member findMember = queryFactory
                .select(member)
                .from(member)
                .where(member.username.eq("member1"))
                .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
}
```

> 같은 테이블을 조인해야 하는 경우엔 선언해서 사용

```java
@SpringBootTest
@Transactional
public class QuerydslBasicTest {

    @Autowired
    EntityManager em;

    JPAQueryFactory queryFactory;
    
    @Test
    public void startQuerydsl(){
        QMember m1 = new QMember("m1");
        
        Member findMember = queryFactory
                .select(m1)
                .from(m1)
                .where(m1.username.eq("member1"))
                .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
}
```

---

## 검색 조건 쿼리

```text
member.username.eq("member1") // username = 'member1'
member.username.ne("member1") //username != 'member1'
member.username.eq("member1").not() // username != 'member1'
        
member.username.isNotNull() //이름이 is not null
        
member.age.in(10, 20) // age in (10,20)
member.age.notIn(10, 20) // age not in (10, 20)
member.age.between(10,30) //between 10, 30
        
member.age.goe(30) // age >= 30
member.age.gt(30) // age > 30
member.age.loe(30) // age <= 30
member.age.lt(30) // age < 30
        
member.username.like("member%") //like 검색
member.username.contains("member") // like ‘%member%’ 검색
member.username.startsWith("member") //like ‘member%’ 검색
...
```

---

```java

    @Test
    public void searchAndParam(){
        Member findMember = queryFactory
                .selectFrom(member)
                .where(
                        member.username.eq("member1"),
                        member.age.eq(10))
                .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
```

`where`절 안에서 `and`로 chain을 걸어도 되지만 조건이 `and`인 경우엔 `,`로 대체할 수 있다.

이 경우 `null`값은 무시 되는데, 메서드 추출을 활용해서 동적 쿼리를 깔끔하게 만들 수 있따. 

---

## 결과 조회

---

+ `fetch()`: 리스트 조회, 데이터 없으면 빈 리스트 반환
+ `fetchOne()`: 단 건 조회
  + 결과 없으면 `null`
  + 결과가 둘 이상이면 `com.querydsl.core.NonUniqueResultException`
+ `fetchFirst()`: `limit(1).fetchOne()`
+ `fetchResults()`: 페이징 정보 포함, total count 쿼리 추가 실행
+ `fetchCount()`: count 쿼리로 변경해서 count 수 조회

---

> 스프링 부트 2.6부터는 Querydsl 5.0을 사용하는데 `fetchResults()`와 `fetchCount()`는 Deprecated
